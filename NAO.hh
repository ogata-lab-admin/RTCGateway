// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __NAO_hh__
#define __NAO_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_NAO
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_NAO
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_NAO
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE ssr

_CORBA_MODULE_BEG

  struct ActuatorPosition {
    typedef _CORBA_ConstrType_Variable_Var<ActuatorPosition> _var_type;

    
    ::CORBA::String_member name;

    ::CORBA::Float position;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActuatorPosition::_var_type ActuatorPosition_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ActuatorPosition,ActuatorPosition_var > ActuatorPosition_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActuatorPosition;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActuatorPositionSeq;

  class ActuatorPositionSeq_var;

  class ActuatorPositionSeq : public _CORBA_Unbounded_Sequence< ActuatorPosition >  {
  public:
    typedef ActuatorPositionSeq_var _var_type;
    inline ActuatorPositionSeq() {}
    inline ActuatorPositionSeq(const ActuatorPositionSeq& _s)
      : _CORBA_Unbounded_Sequence< ActuatorPosition > (_s) {}

    inline ActuatorPositionSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< ActuatorPosition > (_max) {}
    inline ActuatorPositionSeq(_CORBA_ULong _max, _CORBA_ULong _len, ActuatorPosition* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< ActuatorPosition > (_max, _len, _val, _rel) {}

  

    inline ActuatorPositionSeq& operator = (const ActuatorPositionSeq& _s) {
      _CORBA_Unbounded_Sequence< ActuatorPosition > ::operator=(_s);
      return *this;
    }
  };

  class ActuatorPositionSeq_out;

  class ActuatorPositionSeq_var {
  public:
    inline ActuatorPositionSeq_var() : _pd_seq(0) {}
    inline ActuatorPositionSeq_var(ActuatorPositionSeq* _s) : _pd_seq(_s) {}
    inline ActuatorPositionSeq_var(const ActuatorPositionSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new ActuatorPositionSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~ActuatorPositionSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline ActuatorPositionSeq_var& operator = (ActuatorPositionSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ActuatorPositionSeq_var& operator = (const ActuatorPositionSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new ActuatorPositionSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ActuatorPosition& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ActuatorPositionSeq* operator -> () { return _pd_seq; }
    inline const ActuatorPositionSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ActuatorPositionSeq& () const { return *_pd_seq; }
#else
    inline operator const ActuatorPositionSeq& () const { return *_pd_seq; }
    inline operator ActuatorPositionSeq& () { return *_pd_seq; }
#endif
      
    inline const ActuatorPositionSeq& in() const { return *_pd_seq; }
    inline ActuatorPositionSeq&       inout()    { return *_pd_seq; }
    inline ActuatorPositionSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ActuatorPositionSeq* _retn() { ActuatorPositionSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ActuatorPositionSeq_out;
    
  private:
    ActuatorPositionSeq* _pd_seq;
  };

  class ActuatorPositionSeq_out {
  public:
    inline ActuatorPositionSeq_out(ActuatorPositionSeq*& _s) : _data(_s) { _data = 0; }
    inline ActuatorPositionSeq_out(ActuatorPositionSeq_var& _s)
      : _data(_s._pd_seq) { _s = (ActuatorPositionSeq*) 0; }
    inline ActuatorPositionSeq_out(const ActuatorPositionSeq_out& _s) : _data(_s._data) {}
    inline ActuatorPositionSeq_out& operator = (const ActuatorPositionSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ActuatorPositionSeq_out& operator = (ActuatorPositionSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator ActuatorPositionSeq*&()  { return _data; }
    inline ActuatorPositionSeq*& ptr()       { return _data; }
    inline ActuatorPositionSeq* operator->() { return _data; }

    inline ActuatorPosition& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ActuatorPositionSeq*& _data;

  private:
    ActuatorPositionSeq_out();
    ActuatorPositionSeq_out& operator=(const ActuatorPositionSeq_var&);
  };

  struct ActuatorPositionArray {
    typedef _CORBA_ConstrType_Variable_Var<ActuatorPositionArray> _var_type;

    
    ActuatorPositionSeq data;

    ::CORBA::Float fractionSpeed;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ActuatorPositionArray::_var_type ActuatorPositionArray_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ActuatorPositionArray,ActuatorPositionArray_var > ActuatorPositionArray_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ActuatorPositionArray;

  struct StringArray {
    typedef _CORBA_ConstrType_Variable_Var<StringArray> _var_type;

    
    typedef _CORBA_Unbounded_Sequence_String _data_seq;
    _data_seq data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef StringArray::_var_type StringArray_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< StringArray,StringArray_var > StringArray_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringArray;

  struct FloatArray {
    typedef _CORBA_ConstrType_Variable_Var<FloatArray> _var_type;

    
    typedef _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  _data_seq;
    _data_seq data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FloatArray::_var_type FloatArray_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FloatArray,FloatArray_var > FloatArray_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FloatArray;

  struct BoolArray {
    typedef _CORBA_ConstrType_Variable_Var<BoolArray> _var_type;

    
    typedef _CORBA_Unbounded_Sequence_Boolean _data_seq;
    _data_seq data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef BoolArray::_var_type BoolArray_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< BoolArray,BoolArray_var > BoolArray_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BoolArray;

  struct LongArray {
    typedef _CORBA_ConstrType_Variable_Var<LongArray> _var_type;

    
    typedef _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  _data_seq;
    _data_seq data;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LongArray::_var_type LongArray_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< LongArray,LongArray_var > LongArray_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LongArray;

#ifndef __ssr_mALMotion__
#define __ssr_mALMotion__

  class ALMotion;
  class _objref_ALMotion;
  class _impl_ALMotion;
  
  typedef _objref_ALMotion* ALMotion_ptr;
  typedef ALMotion_ptr ALMotionRef;

  class ALMotion_Helper {
  public:
    typedef ALMotion_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ALMotion, ALMotion_Helper> ALMotion_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ALMotion,ALMotion_Helper > ALMotion_out;

#endif

  // interface ALMotion
  class ALMotion {
  public:
    // Declarations for this interface type.
    typedef ALMotion_ptr _ptr_type;
    typedef ALMotion_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ALMotion :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void setAngles(const ::ssr::StringArray& name, const ::ssr::FloatArray& value, ::CORBA::Float fractionSpeed);
    FloatArray* getAngles(const ::ssr::StringArray& name, ::CORBA::Boolean useSensors);
    void openHane(const char* name);
    void closeHand(const char* name);
    void setStiffness(const ::ssr::StringArray& name, const ::ssr::FloatArray& stiffnesses);
    FloatArray* getStiffness(const ::ssr::StringArray& name);
    void rest();
    void wakeUp();
    void moveTo(::CORBA::Float x, ::CORBA::Float y, ::CORBA::Float theta);
    void moveToward(::CORBA::Float vx, ::CORBA::Float vy, ::CORBA::Float vtheta);
    FloatArray* getRobotPosition();
    FloatArray* getRobotVelocity();
    void stopMove();
    ::CORBA::Boolean moveIsActive();
    void waitUntilMoveIsFinished();
    void moveInit();
    void setWalkArmEnabled(::CORBA::Boolean leftArmEnable, ::CORBA::Boolean rightArmEnable);
    BoolArray* getWalkArmEnabled();
    FloatArray* getPosition(const char* name, ::CORBA::Long space, ::CORBA::Boolean useSensors);
    void setPosition(const char* name, ::CORBA::Long space, const ::ssr::FloatArray& position, ::CORBA::Float fractionMaxSpeed, ::CORBA::Long axisMask);
    void setTransform(const char* name, ::CORBA::Long space, const ::ssr::FloatArray& transform, ::CORBA::Float fractionMaxSpeed, ::CORBA::Long axisMask);
    FloatArray* getTransform(const char* name, ::CORBA::Long space, ::CORBA::Boolean useSensorValues);

    inline _objref_ALMotion()  { _PR_setobj(0); }  // nil
    _objref_ALMotion(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ALMotion();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ALMotion(const _objref_ALMotion&);
    _objref_ALMotion& operator = (const _objref_ALMotion&);
    // not implemented

    friend class ALMotion;
  };

  class _pof_ALMotion : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ALMotion() : _OMNI_NS(proxyObjectFactory)(ALMotion::_PD_repoId) {}
    virtual ~_pof_ALMotion();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ALMotion :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ALMotion();

    virtual void setAngles(const ::ssr::StringArray& name, const ::ssr::FloatArray& value, ::CORBA::Float fractionSpeed) = 0;
    virtual FloatArray* getAngles(const ::ssr::StringArray& name, ::CORBA::Boolean useSensors) = 0;
    virtual void openHane(const char* name) = 0;
    virtual void closeHand(const char* name) = 0;
    virtual void setStiffness(const ::ssr::StringArray& name, const ::ssr::FloatArray& stiffnesses) = 0;
    virtual FloatArray* getStiffness(const ::ssr::StringArray& name) = 0;
    virtual void rest() = 0;
    virtual void wakeUp() = 0;
    virtual void moveTo(::CORBA::Float x, ::CORBA::Float y, ::CORBA::Float theta) = 0;
    virtual void moveToward(::CORBA::Float vx, ::CORBA::Float vy, ::CORBA::Float vtheta) = 0;
    virtual FloatArray* getRobotPosition() = 0;
    virtual FloatArray* getRobotVelocity() = 0;
    virtual void stopMove() = 0;
    virtual ::CORBA::Boolean moveIsActive() = 0;
    virtual void waitUntilMoveIsFinished() = 0;
    virtual void moveInit() = 0;
    virtual void setWalkArmEnabled(::CORBA::Boolean leftArmEnable, ::CORBA::Boolean rightArmEnable) = 0;
    virtual BoolArray* getWalkArmEnabled() = 0;
    virtual FloatArray* getPosition(const char* name, ::CORBA::Long space, ::CORBA::Boolean useSensors) = 0;
    virtual void setPosition(const char* name, ::CORBA::Long space, const ::ssr::FloatArray& position, ::CORBA::Float fractionMaxSpeed, ::CORBA::Long axisMask) = 0;
    virtual void setTransform(const char* name, ::CORBA::Long space, const ::ssr::FloatArray& transform, ::CORBA::Float fractionMaxSpeed, ::CORBA::Long axisMask) = 0;
    virtual FloatArray* getTransform(const char* name, ::CORBA::Long space, ::CORBA::Boolean useSensorValues) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ALMotion;

#ifndef __ssr_mALTextToSpeech__
#define __ssr_mALTextToSpeech__

  class ALTextToSpeech;
  class _objref_ALTextToSpeech;
  class _impl_ALTextToSpeech;
  
  typedef _objref_ALTextToSpeech* ALTextToSpeech_ptr;
  typedef ALTextToSpeech_ptr ALTextToSpeechRef;

  class ALTextToSpeech_Helper {
  public:
    typedef ALTextToSpeech_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ALTextToSpeech, ALTextToSpeech_Helper> ALTextToSpeech_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ALTextToSpeech,ALTextToSpeech_Helper > ALTextToSpeech_out;

#endif

  // interface ALTextToSpeech
  class ALTextToSpeech {
  public:
    // Declarations for this interface type.
    typedef ALTextToSpeech_ptr _ptr_type;
    typedef ALTextToSpeech_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ALTextToSpeech :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void say(const char* stringToSay);
    void setVolume(::CORBA::Float volume);
    ::CORBA::Float getVolume();
    void setLanguage(const char* language);
    char* getLanguage();
    StringArray* getAvailableLanguages();

    inline _objref_ALTextToSpeech()  { _PR_setobj(0); }  // nil
    _objref_ALTextToSpeech(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ALTextToSpeech();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ALTextToSpeech(const _objref_ALTextToSpeech&);
    _objref_ALTextToSpeech& operator = (const _objref_ALTextToSpeech&);
    // not implemented

    friend class ALTextToSpeech;
  };

  class _pof_ALTextToSpeech : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ALTextToSpeech() : _OMNI_NS(proxyObjectFactory)(ALTextToSpeech::_PD_repoId) {}
    virtual ~_pof_ALTextToSpeech();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ALTextToSpeech :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ALTextToSpeech();

    virtual void say(const char* stringToSay) = 0;
    virtual void setVolume(::CORBA::Float volume) = 0;
    virtual ::CORBA::Float getVolume() = 0;
    virtual void setLanguage(const char* language) = 0;
    virtual char* getLanguage() = 0;
    virtual StringArray* getAvailableLanguages() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ALTextToSpeech;

#ifndef __ssr_mALBehaviorManager__
#define __ssr_mALBehaviorManager__

  class ALBehaviorManager;
  class _objref_ALBehaviorManager;
  class _impl_ALBehaviorManager;
  
  typedef _objref_ALBehaviorManager* ALBehaviorManager_ptr;
  typedef ALBehaviorManager_ptr ALBehaviorManagerRef;

  class ALBehaviorManager_Helper {
  public:
    typedef ALBehaviorManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ALBehaviorManager, ALBehaviorManager_Helper> ALBehaviorManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ALBehaviorManager,ALBehaviorManager_Helper > ALBehaviorManager_out;

#endif

  // interface ALBehaviorManager
  class ALBehaviorManager {
  public:
    // Declarations for this interface type.
    typedef ALBehaviorManager_ptr _ptr_type;
    typedef ALBehaviorManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ALBehaviorManager :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    StringArray* getInstalledBehaviors();
    StringArray* getRunningBehaviors();
    ::CORBA::Boolean isBehaviorInstalled(const char* name);
    ::CORBA::Boolean isBehaviorRunning(const char* name);
    void runBehavior(const char* name);
    void stopAllBehaviors();
    void stopBehavior(const char* name);

    inline _objref_ALBehaviorManager()  { _PR_setobj(0); }  // nil
    _objref_ALBehaviorManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ALBehaviorManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ALBehaviorManager(const _objref_ALBehaviorManager&);
    _objref_ALBehaviorManager& operator = (const _objref_ALBehaviorManager&);
    // not implemented

    friend class ALBehaviorManager;
  };

  class _pof_ALBehaviorManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ALBehaviorManager() : _OMNI_NS(proxyObjectFactory)(ALBehaviorManager::_PD_repoId) {}
    virtual ~_pof_ALBehaviorManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ALBehaviorManager :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ALBehaviorManager();

    virtual StringArray* getInstalledBehaviors() = 0;
    virtual StringArray* getRunningBehaviors() = 0;
    virtual ::CORBA::Boolean isBehaviorInstalled(const char* name) = 0;
    virtual ::CORBA::Boolean isBehaviorRunning(const char* name) = 0;
    virtual void runBehavior(const char* name) = 0;
    virtual void stopAllBehaviors() = 0;
    virtual void stopBehavior(const char* name) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ALBehaviorManager;

#ifndef __ssr_mALMemory__
#define __ssr_mALMemory__

  class ALMemory;
  class _objref_ALMemory;
  class _impl_ALMemory;
  
  typedef _objref_ALMemory* ALMemory_ptr;
  typedef ALMemory_ptr ALMemoryRef;

  class ALMemory_Helper {
  public:
    typedef ALMemory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ALMemory, ALMemory_Helper> ALMemory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ALMemory,ALMemory_Helper > ALMemory_out;

#endif

  // interface ALMemory
  class ALMemory {
  public:
    // Declarations for this interface type.
    typedef ALMemory_ptr _ptr_type;
    typedef ALMemory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ALMemory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void insertLongData(const char* name, ::CORBA::Long value);
    void insertFloatData(const char* name, ::CORBA::Long value);
    void insertStringData(const char* name, const char* value);
    void insertoLongArrayData(const char* name, const ::ssr::LongArray& value);
    void insertoFloatArrayData(const char* name, const ::ssr::FloatArray& value);
    void insertoStringArrayData(const char* name, const ::ssr::StringArray& value);
    ::CORBA::Long getLongData(const char* name);
    ::CORBA::Float getFloatData(const char* name);
    char* getStringData(const char* name);
    LongArray* getLongArrayData(const char* name);
    FloatArray* getFloatArrayData(const char* name);
    StringArray* getStringArrayData(const char* name);

    inline _objref_ALMemory()  { _PR_setobj(0); }  // nil
    _objref_ALMemory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ALMemory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ALMemory(const _objref_ALMemory&);
    _objref_ALMemory& operator = (const _objref_ALMemory&);
    // not implemented

    friend class ALMemory;
  };

  class _pof_ALMemory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ALMemory() : _OMNI_NS(proxyObjectFactory)(ALMemory::_PD_repoId) {}
    virtual ~_pof_ALMemory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ALMemory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ALMemory();

    virtual void insertLongData(const char* name, ::CORBA::Long value) = 0;
    virtual void insertFloatData(const char* name, ::CORBA::Long value) = 0;
    virtual void insertStringData(const char* name, const char* value) = 0;
    virtual void insertoLongArrayData(const char* name, const ::ssr::LongArray& value) = 0;
    virtual void insertoFloatArrayData(const char* name, const ::ssr::FloatArray& value) = 0;
    virtual void insertoStringArrayData(const char* name, const ::ssr::StringArray& value) = 0;
    virtual ::CORBA::Long getLongData(const char* name) = 0;
    virtual ::CORBA::Float getFloatData(const char* name) = 0;
    virtual char* getStringData(const char* name) = 0;
    virtual LongArray* getLongArrayData(const char* name) = 0;
    virtual FloatArray* getFloatArrayData(const char* name) = 0;
    virtual StringArray* getStringArrayData(const char* name) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ALMemory;

#ifndef __ssr_mALVideoDevice__
#define __ssr_mALVideoDevice__

  class ALVideoDevice;
  class _objref_ALVideoDevice;
  class _impl_ALVideoDevice;
  
  typedef _objref_ALVideoDevice* ALVideoDevice_ptr;
  typedef ALVideoDevice_ptr ALVideoDeviceRef;

  class ALVideoDevice_Helper {
  public:
    typedef ALVideoDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ALVideoDevice, ALVideoDevice_Helper> ALVideoDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ALVideoDevice,ALVideoDevice_Helper > ALVideoDevice_out;

#endif

  // interface ALVideoDevice
  class ALVideoDevice {
  public:
    // Declarations for this interface type.
    typedef ALVideoDevice_ptr _ptr_type;
    typedef ALVideoDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ALVideoDevice :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    ::CORBA::Long getCameraModel(::CORBA::Long index);
    ::CORBA::Long getFrameRate(::CORBA::Long index);
    ::CORBA::Long getResolution(::CORBA::Long index);
    ::CORBA::Long getColorSpace(::CORBA::Long index);
    ::CORBA::Boolean setCameraParameter(::CORBA::Long id, ::CORBA::Long value);
    ::CORBA::Long getCameraParameter(::CORBA::Long id);
    ::CORBA::Boolean setCameraParameterToDefault(::CORBA::Long id);

    inline _objref_ALVideoDevice()  { _PR_setobj(0); }  // nil
    _objref_ALVideoDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ALVideoDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ALVideoDevice(const _objref_ALVideoDevice&);
    _objref_ALVideoDevice& operator = (const _objref_ALVideoDevice&);
    // not implemented

    friend class ALVideoDevice;
  };

  class _pof_ALVideoDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ALVideoDevice() : _OMNI_NS(proxyObjectFactory)(ALVideoDevice::_PD_repoId) {}
    virtual ~_pof_ALVideoDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ALVideoDevice :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ALVideoDevice();

    virtual ::CORBA::Long getCameraModel(::CORBA::Long index) = 0;
    virtual ::CORBA::Long getFrameRate(::CORBA::Long index) = 0;
    virtual ::CORBA::Long getResolution(::CORBA::Long index) = 0;
    virtual ::CORBA::Long getColorSpace(::CORBA::Long index) = 0;
    virtual ::CORBA::Boolean setCameraParameter(::CORBA::Long id, ::CORBA::Long value) = 0;
    virtual ::CORBA::Long getCameraParameter(::CORBA::Long id) = 0;
    virtual ::CORBA::Boolean setCameraParameterToDefault(::CORBA::Long id) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ALVideoDevice;

#ifndef __ssr_mALLeds__
#define __ssr_mALLeds__

  class ALLeds;
  class _objref_ALLeds;
  class _impl_ALLeds;
  
  typedef _objref_ALLeds* ALLeds_ptr;
  typedef ALLeds_ptr ALLedsRef;

  class ALLeds_Helper {
  public:
    typedef ALLeds_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ALLeds, ALLeds_Helper> ALLeds_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ALLeds,ALLeds_Helper > ALLeds_out;

#endif

  // interface ALLeds
  class ALLeds {
  public:
    // Declarations for this interface type.
    typedef ALLeds_ptr _ptr_type;
    typedef ALLeds_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_ALLeds :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void fade(const char* name, ::CORBA::Float intensity, ::CORBA::Float duration);
    void fadeRGB(const char* name, ::CORBA::Long rgb, ::CORBA::Float duration);

    inline _objref_ALLeds()  { _PR_setobj(0); }  // nil
    _objref_ALLeds(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ALLeds();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ALLeds(const _objref_ALLeds&);
    _objref_ALLeds& operator = (const _objref_ALLeds&);
    // not implemented

    friend class ALLeds;
  };

  class _pof_ALLeds : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ALLeds() : _OMNI_NS(proxyObjectFactory)(ALLeds::_PD_repoId) {}
    virtual ~_pof_ALLeds();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ALLeds :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ALLeds();

    virtual void fade(const char* name, ::CORBA::Float intensity, ::CORBA::Float duration) = 0;
    virtual void fadeRGB(const char* name, ::CORBA::Long rgb, ::CORBA::Float duration) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ALLeds;

_CORBA_MODULE_END



_CORBA_MODULE POA_ssr
_CORBA_MODULE_BEG

  class ALMotion :
    public virtual ssr::_impl_ALMotion,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ALMotion();

    inline ::ssr::ALMotion_ptr _this() {
      return (::ssr::ALMotion_ptr) _do_this(::ssr::ALMotion::_PD_repoId);
    }
  };

  class ALTextToSpeech :
    public virtual ssr::_impl_ALTextToSpeech,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ALTextToSpeech();

    inline ::ssr::ALTextToSpeech_ptr _this() {
      return (::ssr::ALTextToSpeech_ptr) _do_this(::ssr::ALTextToSpeech::_PD_repoId);
    }
  };

  class ALBehaviorManager :
    public virtual ssr::_impl_ALBehaviorManager,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ALBehaviorManager();

    inline ::ssr::ALBehaviorManager_ptr _this() {
      return (::ssr::ALBehaviorManager_ptr) _do_this(::ssr::ALBehaviorManager::_PD_repoId);
    }
  };

  class ALMemory :
    public virtual ssr::_impl_ALMemory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ALMemory();

    inline ::ssr::ALMemory_ptr _this() {
      return (::ssr::ALMemory_ptr) _do_this(::ssr::ALMemory::_PD_repoId);
    }
  };

  class ALVideoDevice :
    public virtual ssr::_impl_ALVideoDevice,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ALVideoDevice();

    inline ::ssr::ALVideoDevice_ptr _this() {
      return (::ssr::ALVideoDevice_ptr) _do_this(::ssr::ALVideoDevice::_PD_repoId);
    }
  };

  class ALLeds :
    public virtual ssr::_impl_ALLeds,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ALLeds();

    inline ::ssr::ALLeds_ptr _this() {
      return (::ssr::ALLeds_ptr) _do_this(::ssr::ALLeds::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_ssr
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const ssr::ActuatorPosition& _s);
extern void operator<<=(::CORBA::Any& _a, ssr::ActuatorPosition* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ActuatorPosition*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::ActuatorPosition*& _sp);

void operator<<=(::CORBA::Any& _a, const ssr::ActuatorPositionSeq& _s);
void operator<<=(::CORBA::Any& _a, ssr::ActuatorPositionSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ActuatorPositionSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::ActuatorPositionSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const ssr::ActuatorPositionArray& _s);
extern void operator<<=(::CORBA::Any& _a, ssr::ActuatorPositionArray* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ActuatorPositionArray*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::ActuatorPositionArray*& _sp);

extern void operator<<=(::CORBA::Any& _a, const ssr::StringArray& _s);
extern void operator<<=(::CORBA::Any& _a, ssr::StringArray* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::StringArray*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::StringArray*& _sp);

extern void operator<<=(::CORBA::Any& _a, const ssr::FloatArray& _s);
extern void operator<<=(::CORBA::Any& _a, ssr::FloatArray* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::FloatArray*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::FloatArray*& _sp);

extern void operator<<=(::CORBA::Any& _a, const ssr::BoolArray& _s);
extern void operator<<=(::CORBA::Any& _a, ssr::BoolArray* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::BoolArray*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::BoolArray*& _sp);

extern void operator<<=(::CORBA::Any& _a, const ssr::LongArray& _s);
extern void operator<<=(::CORBA::Any& _a, ssr::LongArray* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::LongArray*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const ssr::LongArray*& _sp);

void operator<<=(::CORBA::Any& _a, ssr::ALMotion_ptr _s);
void operator<<=(::CORBA::Any& _a, ssr::ALMotion_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALMotion_ptr& _s);

void operator<<=(::CORBA::Any& _a, ssr::ALTextToSpeech_ptr _s);
void operator<<=(::CORBA::Any& _a, ssr::ALTextToSpeech_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALTextToSpeech_ptr& _s);

void operator<<=(::CORBA::Any& _a, ssr::ALBehaviorManager_ptr _s);
void operator<<=(::CORBA::Any& _a, ssr::ALBehaviorManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALBehaviorManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, ssr::ALMemory_ptr _s);
void operator<<=(::CORBA::Any& _a, ssr::ALMemory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALMemory_ptr& _s);

void operator<<=(::CORBA::Any& _a, ssr::ALVideoDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, ssr::ALVideoDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALVideoDevice_ptr& _s);

void operator<<=(::CORBA::Any& _a, ssr::ALLeds_ptr _s);
void operator<<=(::CORBA::Any& _a, ssr::ALLeds_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALLeds_ptr& _s);



inline void
ssr::ALMotion::_marshalObjRef(::ssr::ALMotion_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ssr::ALTextToSpeech::_marshalObjRef(::ssr::ALTextToSpeech_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ssr::ALBehaviorManager::_marshalObjRef(::ssr::ALBehaviorManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ssr::ALMemory::_marshalObjRef(::ssr::ALMemory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ssr::ALVideoDevice::_marshalObjRef(::ssr::ALVideoDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ssr::ALLeds::_marshalObjRef(::ssr::ALLeds_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_NAO
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_NAO
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_NAO
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_NAO
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_NAO
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_NAO
#endif

#endif  // __NAO_hh__

