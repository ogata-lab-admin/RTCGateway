// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "NAO.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_ssr_mActuatorPosition[] = {
  {"name", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"position", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_ssr_mActuatorPosition
#  undef _0RL_tc_ssr_mActuatorPosition
#endif
static CORBA::TypeCode_ptr _0RL_tc_ssr_mActuatorPosition = CORBA::TypeCode::PR_struct_tc("IDL:ssr/ActuatorPosition:1.0", "ActuatorPosition", _0RL_structmember_ssr_mActuatorPosition, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ActuatorPosition = _0RL_tc_ssr_mActuatorPosition;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ActuatorPosition = _0RL_tc_ssr_mActuatorPosition;
#endif






static CORBA::TypeCode_ptr _0RL_tc_ssr_mActuatorPositionSeq = CORBA::TypeCode::PR_alias_tc("IDL:ssr/ActuatorPositionSeq:1.0", "ActuatorPositionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_ssr_mActuatorPosition, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ActuatorPositionSeq = _0RL_tc_ssr_mActuatorPositionSeq;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ActuatorPositionSeq = _0RL_tc_ssr_mActuatorPositionSeq;
#endif


static CORBA::PR_structMember _0RL_structmember_ssr_mActuatorPositionArray[] = {
  {"data", _0RL_tc_ssr_mActuatorPositionSeq},
  {"fractionSpeed", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_ssr_mActuatorPositionArray
#  undef _0RL_tc_ssr_mActuatorPositionArray
#endif
static CORBA::TypeCode_ptr _0RL_tc_ssr_mActuatorPositionArray = CORBA::TypeCode::PR_struct_tc("IDL:ssr/ActuatorPositionArray:1.0", "ActuatorPositionArray", _0RL_structmember_ssr_mActuatorPositionArray, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ActuatorPositionArray = _0RL_tc_ssr_mActuatorPositionArray;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ActuatorPositionArray = _0RL_tc_ssr_mActuatorPositionArray;
#endif


static CORBA::PR_structMember _0RL_structmember_ssr_mStringArray[] = {
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_ssr_mStringArray
#  undef _0RL_tc_ssr_mStringArray
#endif
static CORBA::TypeCode_ptr _0RL_tc_ssr_mStringArray = CORBA::TypeCode::PR_struct_tc("IDL:ssr/StringArray:1.0", "StringArray", _0RL_structmember_ssr_mStringArray, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_StringArray = _0RL_tc_ssr_mStringArray;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_StringArray = _0RL_tc_ssr_mStringArray;
#endif


static CORBA::PR_structMember _0RL_structmember_ssr_mFloatArray[] = {
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_float_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_ssr_mFloatArray
#  undef _0RL_tc_ssr_mFloatArray
#endif
static CORBA::TypeCode_ptr _0RL_tc_ssr_mFloatArray = CORBA::TypeCode::PR_struct_tc("IDL:ssr/FloatArray:1.0", "FloatArray", _0RL_structmember_ssr_mFloatArray, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_FloatArray = _0RL_tc_ssr_mFloatArray;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_FloatArray = _0RL_tc_ssr_mFloatArray;
#endif


static CORBA::PR_structMember _0RL_structmember_ssr_mBoolArray[] = {
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_boolean_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_ssr_mBoolArray
#  undef _0RL_tc_ssr_mBoolArray
#endif
static CORBA::TypeCode_ptr _0RL_tc_ssr_mBoolArray = CORBA::TypeCode::PR_struct_tc("IDL:ssr/BoolArray:1.0", "BoolArray", _0RL_structmember_ssr_mBoolArray, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_BoolArray = _0RL_tc_ssr_mBoolArray;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_BoolArray = _0RL_tc_ssr_mBoolArray;
#endif


static CORBA::PR_structMember _0RL_structmember_ssr_mLongArray[] = {
  {"data", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_long_tc(), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_ssr_mLongArray
#  undef _0RL_tc_ssr_mLongArray
#endif
static CORBA::TypeCode_ptr _0RL_tc_ssr_mLongArray = CORBA::TypeCode::PR_struct_tc("IDL:ssr/LongArray:1.0", "LongArray", _0RL_structmember_ssr_mLongArray, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_LongArray = _0RL_tc_ssr_mLongArray;
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_LongArray = _0RL_tc_ssr_mLongArray;
#endif


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ALMotion = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALMotion:1.0", "ALMotion", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ALMotion = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALMotion:1.0", "ALMotion", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ALTextToSpeech = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALTextToSpeech:1.0", "ALTextToSpeech", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ALTextToSpeech = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALTextToSpeech:1.0", "ALTextToSpeech", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ALBehaviorManager = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALBehaviorManager:1.0", "ALBehaviorManager", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ALBehaviorManager = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALBehaviorManager:1.0", "ALBehaviorManager", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ALMemory = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALMemory:1.0", "ALMemory", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ALMemory = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALMemory:1.0", "ALMemory", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ALVideoDevice = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALVideoDevice:1.0", "ALVideoDevice", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ALVideoDevice = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALVideoDevice:1.0", "ALVideoDevice", &_0RL_tcTrack);
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace ssr { 
  const ::CORBA::TypeCode_ptr _tc_ALLeds = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALLeds:1.0", "ALLeds", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr ssr::_tc_ALLeds = CORBA::TypeCode::PR_interface_tc("IDL:ssr/ALLeds:1.0", "ALLeds", &_0RL_tcTrack);
#endif

static void _0RL_ssr_mActuatorPosition_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::ActuatorPosition* _p = (ssr::ActuatorPosition*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mActuatorPosition_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::ActuatorPosition* _p = new ssr::ActuatorPosition;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mActuatorPosition_destructor_fn(void* _v)
{
  ssr::ActuatorPosition* _p = (ssr::ActuatorPosition*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::ActuatorPosition& _s)
{
  ssr::ActuatorPosition* _p = new ssr::ActuatorPosition(_s);
  _a.PR_insert(_0RL_tc_ssr_mActuatorPosition,
               _0RL_ssr_mActuatorPosition_marshal_fn,
               _0RL_ssr_mActuatorPosition_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::ActuatorPosition* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mActuatorPosition,
               _0RL_ssr_mActuatorPosition_marshal_fn,
               _0RL_ssr_mActuatorPosition_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ActuatorPosition*& _sp)
{
  return _a >>= (const ssr::ActuatorPosition*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::ActuatorPosition*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mActuatorPosition,
                    _0RL_ssr_mActuatorPosition_unmarshal_fn,
                    _0RL_ssr_mActuatorPosition_marshal_fn,
                    _0RL_ssr_mActuatorPosition_destructor_fn,
                    _v)) {
    _sp = (const ssr::ActuatorPosition*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mActuatorPositionSeq_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::ActuatorPositionSeq* _p = (ssr::ActuatorPositionSeq*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mActuatorPositionSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::ActuatorPositionSeq* _p = new ssr::ActuatorPositionSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mActuatorPositionSeq_destructor_fn(void* _v)
{
  ssr::ActuatorPositionSeq* _p = (ssr::ActuatorPositionSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::ActuatorPositionSeq& _s)
{
  ssr::ActuatorPositionSeq* _p = new ssr::ActuatorPositionSeq(_s);
  _a.PR_insert(_0RL_tc_ssr_mActuatorPositionSeq,
               _0RL_ssr_mActuatorPositionSeq_marshal_fn,
               _0RL_ssr_mActuatorPositionSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::ActuatorPositionSeq* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mActuatorPositionSeq,
               _0RL_ssr_mActuatorPositionSeq_marshal_fn,
               _0RL_ssr_mActuatorPositionSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ActuatorPositionSeq*& _sp)
{
  return _a >>= (const ssr::ActuatorPositionSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::ActuatorPositionSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mActuatorPositionSeq,
                    _0RL_ssr_mActuatorPositionSeq_unmarshal_fn,
                    _0RL_ssr_mActuatorPositionSeq_marshal_fn,
                    _0RL_ssr_mActuatorPositionSeq_destructor_fn,
                    _v)) {
    _sp = (const ssr::ActuatorPositionSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mActuatorPositionArray_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::ActuatorPositionArray* _p = (ssr::ActuatorPositionArray*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mActuatorPositionArray_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::ActuatorPositionArray* _p = new ssr::ActuatorPositionArray;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mActuatorPositionArray_destructor_fn(void* _v)
{
  ssr::ActuatorPositionArray* _p = (ssr::ActuatorPositionArray*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::ActuatorPositionArray& _s)
{
  ssr::ActuatorPositionArray* _p = new ssr::ActuatorPositionArray(_s);
  _a.PR_insert(_0RL_tc_ssr_mActuatorPositionArray,
               _0RL_ssr_mActuatorPositionArray_marshal_fn,
               _0RL_ssr_mActuatorPositionArray_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::ActuatorPositionArray* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mActuatorPositionArray,
               _0RL_ssr_mActuatorPositionArray_marshal_fn,
               _0RL_ssr_mActuatorPositionArray_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ActuatorPositionArray*& _sp)
{
  return _a >>= (const ssr::ActuatorPositionArray*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::ActuatorPositionArray*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mActuatorPositionArray,
                    _0RL_ssr_mActuatorPositionArray_unmarshal_fn,
                    _0RL_ssr_mActuatorPositionArray_marshal_fn,
                    _0RL_ssr_mActuatorPositionArray_destructor_fn,
                    _v)) {
    _sp = (const ssr::ActuatorPositionArray*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mStringArray_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::StringArray* _p = (ssr::StringArray*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mStringArray_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::StringArray* _p = new ssr::StringArray;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mStringArray_destructor_fn(void* _v)
{
  ssr::StringArray* _p = (ssr::StringArray*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::StringArray& _s)
{
  ssr::StringArray* _p = new ssr::StringArray(_s);
  _a.PR_insert(_0RL_tc_ssr_mStringArray,
               _0RL_ssr_mStringArray_marshal_fn,
               _0RL_ssr_mStringArray_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::StringArray* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mStringArray,
               _0RL_ssr_mStringArray_marshal_fn,
               _0RL_ssr_mStringArray_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::StringArray*& _sp)
{
  return _a >>= (const ssr::StringArray*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::StringArray*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mStringArray,
                    _0RL_ssr_mStringArray_unmarshal_fn,
                    _0RL_ssr_mStringArray_marshal_fn,
                    _0RL_ssr_mStringArray_destructor_fn,
                    _v)) {
    _sp = (const ssr::StringArray*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mFloatArray_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::FloatArray* _p = (ssr::FloatArray*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mFloatArray_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::FloatArray* _p = new ssr::FloatArray;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mFloatArray_destructor_fn(void* _v)
{
  ssr::FloatArray* _p = (ssr::FloatArray*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::FloatArray& _s)
{
  ssr::FloatArray* _p = new ssr::FloatArray(_s);
  _a.PR_insert(_0RL_tc_ssr_mFloatArray,
               _0RL_ssr_mFloatArray_marshal_fn,
               _0RL_ssr_mFloatArray_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::FloatArray* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mFloatArray,
               _0RL_ssr_mFloatArray_marshal_fn,
               _0RL_ssr_mFloatArray_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::FloatArray*& _sp)
{
  return _a >>= (const ssr::FloatArray*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::FloatArray*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mFloatArray,
                    _0RL_ssr_mFloatArray_unmarshal_fn,
                    _0RL_ssr_mFloatArray_marshal_fn,
                    _0RL_ssr_mFloatArray_destructor_fn,
                    _v)) {
    _sp = (const ssr::FloatArray*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mBoolArray_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::BoolArray* _p = (ssr::BoolArray*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mBoolArray_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::BoolArray* _p = new ssr::BoolArray;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mBoolArray_destructor_fn(void* _v)
{
  ssr::BoolArray* _p = (ssr::BoolArray*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::BoolArray& _s)
{
  ssr::BoolArray* _p = new ssr::BoolArray(_s);
  _a.PR_insert(_0RL_tc_ssr_mBoolArray,
               _0RL_ssr_mBoolArray_marshal_fn,
               _0RL_ssr_mBoolArray_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::BoolArray* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mBoolArray,
               _0RL_ssr_mBoolArray_marshal_fn,
               _0RL_ssr_mBoolArray_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::BoolArray*& _sp)
{
  return _a >>= (const ssr::BoolArray*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::BoolArray*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mBoolArray,
                    _0RL_ssr_mBoolArray_unmarshal_fn,
                    _0RL_ssr_mBoolArray_marshal_fn,
                    _0RL_ssr_mBoolArray_destructor_fn,
                    _v)) {
    _sp = (const ssr::BoolArray*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mLongArray_marshal_fn(cdrStream& _s, void* _v)
{
  ssr::LongArray* _p = (ssr::LongArray*)_v;
  *_p >>= _s;
}
static void _0RL_ssr_mLongArray_unmarshal_fn(cdrStream& _s, void*& _v)
{
  ssr::LongArray* _p = new ssr::LongArray;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_ssr_mLongArray_destructor_fn(void* _v)
{
  ssr::LongArray* _p = (ssr::LongArray*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const ssr::LongArray& _s)
{
  ssr::LongArray* _p = new ssr::LongArray(_s);
  _a.PR_insert(_0RL_tc_ssr_mLongArray,
               _0RL_ssr_mLongArray_marshal_fn,
               _0RL_ssr_mLongArray_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, ssr::LongArray* _sp)
{
  _a.PR_insert(_0RL_tc_ssr_mLongArray,
               _0RL_ssr_mLongArray_marshal_fn,
               _0RL_ssr_mLongArray_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::LongArray*& _sp)
{
  return _a >>= (const ssr::LongArray*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const ssr::LongArray*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_ssr_mLongArray,
                    _0RL_ssr_mLongArray_unmarshal_fn,
                    _0RL_ssr_mLongArray_marshal_fn,
                    _0RL_ssr_mLongArray_destructor_fn,
                    _v)) {
    _sp = (const ssr::LongArray*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mALMotion_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_ssr_mALMotion_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(ssr::ALMotion::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_ssr_mALMotion_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, ssr::ALMotion_ptr _o)
{
  ssr::ALMotion_ptr _no = ssr::ALMotion::_duplicate(_o);
  _a.PR_insert(ssr::_tc_ALMotion,
               _0RL_ssr_mALMotion_marshal_fn,
               _0RL_ssr_mALMotion_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, ssr::ALMotion_ptr* _op)
{
  _a.PR_insert(ssr::_tc_ALMotion,
               _0RL_ssr_mALMotion_marshal_fn,
               _0RL_ssr_mALMotion_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = ssr::ALMotion::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALMotion_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(ssr::_tc_ALMotion,
                    _0RL_ssr_mALMotion_unmarshal_fn,
                    _0RL_ssr_mALMotion_marshal_fn,
                    _0RL_ssr_mALMotion_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (ssr::ALMotion_ptr)_r->_ptrToObjRef(ssr::ALMotion::_PD_repoId);
    else
      _o = ssr::ALMotion::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mALTextToSpeech_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_ssr_mALTextToSpeech_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(ssr::ALTextToSpeech::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_ssr_mALTextToSpeech_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, ssr::ALTextToSpeech_ptr _o)
{
  ssr::ALTextToSpeech_ptr _no = ssr::ALTextToSpeech::_duplicate(_o);
  _a.PR_insert(ssr::_tc_ALTextToSpeech,
               _0RL_ssr_mALTextToSpeech_marshal_fn,
               _0RL_ssr_mALTextToSpeech_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, ssr::ALTextToSpeech_ptr* _op)
{
  _a.PR_insert(ssr::_tc_ALTextToSpeech,
               _0RL_ssr_mALTextToSpeech_marshal_fn,
               _0RL_ssr_mALTextToSpeech_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = ssr::ALTextToSpeech::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALTextToSpeech_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(ssr::_tc_ALTextToSpeech,
                    _0RL_ssr_mALTextToSpeech_unmarshal_fn,
                    _0RL_ssr_mALTextToSpeech_marshal_fn,
                    _0RL_ssr_mALTextToSpeech_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (ssr::ALTextToSpeech_ptr)_r->_ptrToObjRef(ssr::ALTextToSpeech::_PD_repoId);
    else
      _o = ssr::ALTextToSpeech::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mALBehaviorManager_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_ssr_mALBehaviorManager_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(ssr::ALBehaviorManager::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_ssr_mALBehaviorManager_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, ssr::ALBehaviorManager_ptr _o)
{
  ssr::ALBehaviorManager_ptr _no = ssr::ALBehaviorManager::_duplicate(_o);
  _a.PR_insert(ssr::_tc_ALBehaviorManager,
               _0RL_ssr_mALBehaviorManager_marshal_fn,
               _0RL_ssr_mALBehaviorManager_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, ssr::ALBehaviorManager_ptr* _op)
{
  _a.PR_insert(ssr::_tc_ALBehaviorManager,
               _0RL_ssr_mALBehaviorManager_marshal_fn,
               _0RL_ssr_mALBehaviorManager_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = ssr::ALBehaviorManager::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALBehaviorManager_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(ssr::_tc_ALBehaviorManager,
                    _0RL_ssr_mALBehaviorManager_unmarshal_fn,
                    _0RL_ssr_mALBehaviorManager_marshal_fn,
                    _0RL_ssr_mALBehaviorManager_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (ssr::ALBehaviorManager_ptr)_r->_ptrToObjRef(ssr::ALBehaviorManager::_PD_repoId);
    else
      _o = ssr::ALBehaviorManager::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mALMemory_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_ssr_mALMemory_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(ssr::ALMemory::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_ssr_mALMemory_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, ssr::ALMemory_ptr _o)
{
  ssr::ALMemory_ptr _no = ssr::ALMemory::_duplicate(_o);
  _a.PR_insert(ssr::_tc_ALMemory,
               _0RL_ssr_mALMemory_marshal_fn,
               _0RL_ssr_mALMemory_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, ssr::ALMemory_ptr* _op)
{
  _a.PR_insert(ssr::_tc_ALMemory,
               _0RL_ssr_mALMemory_marshal_fn,
               _0RL_ssr_mALMemory_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = ssr::ALMemory::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALMemory_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(ssr::_tc_ALMemory,
                    _0RL_ssr_mALMemory_unmarshal_fn,
                    _0RL_ssr_mALMemory_marshal_fn,
                    _0RL_ssr_mALMemory_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (ssr::ALMemory_ptr)_r->_ptrToObjRef(ssr::ALMemory::_PD_repoId);
    else
      _o = ssr::ALMemory::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mALVideoDevice_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_ssr_mALVideoDevice_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(ssr::ALVideoDevice::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_ssr_mALVideoDevice_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, ssr::ALVideoDevice_ptr _o)
{
  ssr::ALVideoDevice_ptr _no = ssr::ALVideoDevice::_duplicate(_o);
  _a.PR_insert(ssr::_tc_ALVideoDevice,
               _0RL_ssr_mALVideoDevice_marshal_fn,
               _0RL_ssr_mALVideoDevice_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, ssr::ALVideoDevice_ptr* _op)
{
  _a.PR_insert(ssr::_tc_ALVideoDevice,
               _0RL_ssr_mALVideoDevice_marshal_fn,
               _0RL_ssr_mALVideoDevice_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = ssr::ALVideoDevice::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALVideoDevice_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(ssr::_tc_ALVideoDevice,
                    _0RL_ssr_mALVideoDevice_unmarshal_fn,
                    _0RL_ssr_mALVideoDevice_marshal_fn,
                    _0RL_ssr_mALVideoDevice_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (ssr::ALVideoDevice_ptr)_r->_ptrToObjRef(ssr::ALVideoDevice::_PD_repoId);
    else
      _o = ssr::ALVideoDevice::_nil();
    return 1;
  }
  return 0;
}

static void _0RL_ssr_mALLeds_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_ssr_mALLeds_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(ssr::ALLeds::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_ssr_mALLeds_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, ssr::ALLeds_ptr _o)
{
  ssr::ALLeds_ptr _no = ssr::ALLeds::_duplicate(_o);
  _a.PR_insert(ssr::_tc_ALLeds,
               _0RL_ssr_mALLeds_marshal_fn,
               _0RL_ssr_mALLeds_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, ssr::ALLeds_ptr* _op)
{
  _a.PR_insert(ssr::_tc_ALLeds,
               _0RL_ssr_mALLeds_marshal_fn,
               _0RL_ssr_mALLeds_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = ssr::ALLeds::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, ssr::ALLeds_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(ssr::_tc_ALLeds,
                    _0RL_ssr_mALLeds_unmarshal_fn,
                    _0RL_ssr_mALLeds_marshal_fn,
                    _0RL_ssr_mALLeds_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (ssr::ALLeds_ptr)_r->_ptrToObjRef(ssr::ALLeds::_PD_repoId);
    else
      _o = ssr::ALLeds::_nil();
    return 1;
  }
  return 0;
}

